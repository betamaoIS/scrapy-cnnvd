# coding=utf-8


import logging
import os
import traceback
from commands import getstatusoutput
import pickle
from pprint import pprint
from subprocess import PIPE, STDOUT, Popen
from my_logger import logger

import os
import io
import re

ROOT = r'exploit_db\exploit_db\exploits'
CVE_PAT_RB = re.compile('CVE.*(\d{4}-\d{4,})')
BID_PAT_TXT = re.compile('/bid/(\d+)')
RES = (
    CVE_PAT_RB,
    BID_PAT_TXT
)

CUR_DIR = os.path.dirname(os.path.abspath(__file__))
EXPLOIT_DIR = os.path.join(CUR_DIR, 'exploit_db')


def id_extractor(root_dir, cache='id_extractor.cache', use_cache=True):
    has_extracted = set()
    if use_cache:
        try:
            has_extracted = pickle.load(open(cache, 'rb'))
        except Exception:
            logger.log.info('load cache failed, set it null....')
    cnt = 0
    for root, _, files in os.walk(root_dir):
        for filename in files:
            if filename in has_extracted:
                continue
            path = os.path.join(root, filename)
            # 'CVE', '2009-4265'
            with io.open(path, 'r', encoding='iso8859') as f:
                content = f.read()
            for pat in RES:
                res = pat.findall(content)
                if res:
                    logger.log.info('%s => %s' % (path, str(res)))
            cnt += 1
            if cnt % 5000 == 0:
                logger.log.info('has process %d ...' % cnt)
            has_extracted.add(filename)
    try:
        pickle.dump(has_extracted, open(cache, 'wb'))
    except Exception as e:
        logger.log.info('store cache failed:' + str(e))


def exec_cmd(cmd, cwd=None):
    """
    执行命令并返回退出码与命令输出
    :param cmd: 命令
    :return: (status, output)
    """
    new_process = Popen(cmd, shell=True, stderr=STDOUT, stdout=PIPE, stdin=PIPE, universal_newlines=True, cwd=cwd)
    stdout, stderr = new_process.communicate()
    status = new_process.returncode
    out = u''
    try:
        out = stdout.decode('gbk')
    except Exception as e:
        try:
            out = stdout.decode('utf8')
        except Exception as e:
            logger.log.error('decode the cmd result failed : ' + str(e))
    return status, out


def update_local_file(project_dir):
    """
    升级本地
    :param project_dir:
    :return:
    """
    work_dir = os.path.join(project_dir, 'exploit_db')
    init_dir = os.path.join(work_dir, '.git')
    if not os.path.exists(project_dir):
        logger.info('exploit db project dir not exist, create it...')
        try:
            os.mkdir(project_dir)
        except Exception as e:
            logger.log.error('create dir failed:' + str(e))
    if os.path.exists(init_dir):
        cmd = 'git pull'
    else:
        cmd = 'git clone https://github.com/offensive-security/exploitdb.git exploit_db'

    code, output = exec_cmd(cmd, work_dir)
    return code, output


def main():
    # 注意当使用
    id_extractor(EXPLOIT_DIR)
    # print(update_local_file(EXPLOIT_DIR)[1])


if __name__ == '__main__':
    main()
